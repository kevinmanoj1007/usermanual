"use strict";(self.webpackChunkuser_manual=self.webpackChunkuser_manual||[]).push([[4699],{5503:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"simpackage/simcontroller","title":"Router Handlers","description":"The Controller module defines routing logic for the simulator service. It connects API requests to appropriate handler functions that interact with a SimInterface strategy. Each route parses structured input using Pydantic models, delegates logic to the simulator backend, and returns standardized outputs such as simulation results, extracted data, and modified netlists.","source":"@site/connectors/simpackage/simcontroller.md","sourceDirName":"simpackage","slug":"/simpackage/simcontroller","permalink":"/connectors/simpackage/simcontroller","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"connectorsSidebar","previous":{"title":"SimConnector","permalink":"/connectors/simpackage/simconnector"},"next":{"title":"Connector Models","permalink":"/connectors/simpackage/slim-models"}}');var r=t(4848),s=t(8453);const a={},l="Router Handlers",d={},c=[{value:"Module Definition",id:"module-definition",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Strategy Pattern",id:"strategy-pattern",level:3},{value:"Data Validation",id:"data-validation",level:3},{value:"Handler Functions",id:"handler-functions",level:2},{value:"Dependency Management",id:"dependency-management",level:2},{value:"Graph Operations",id:"graph-operations",level:2},{value:"Design Principles",id:"design-principles",level:2},{value:"Abstraction",id:"abstraction",level:3},{value:"Reliability",id:"reliability",level:3},{value:"Separation of Concerns",id:"separation-of-concerns",level:3},{value:"Dependencies",id:"dependencies",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"router-handlers",children:"Router Handlers"})}),"\n",(0,r.jsxs)(n.p,{children:["The Controller module defines routing logic for the simulator service. It connects API requests to appropriate handler functions that interact with a ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"})," strategy. Each route parses structured input using Pydantic models, delegates logic to the simulator backend, and returns standardized outputs such as simulation results, extracted data, and modified netlists."]}),"\n",(0,r.jsx)(n.h2,{id:"module-definition",children:"Module Definition"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Defined in:"})," ",(0,r.jsx)(n.code,{children:"sim/controller.py"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Modular and extensible routing system suitable for simulators that follow different internal implementations."]}),"\n",(0,r.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"strategy-pattern",children:"Strategy Pattern"}),"\n",(0,r.jsxs)(n.p,{children:["All handlers rely on a ",(0,r.jsx)(n.code,{children:"strategy"})," parameter, which is an instance of a class implementing the ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),". This abstracts backend simulator logic, allowing handlers to remain generic."]}),"\n",(0,r.jsx)(n.h3,{id:"data-validation",children:"Data Validation"}),"\n",(0,r.jsx)(n.p,{children:"All handlers receive validated input data, structured using Pydantic models (e.g., Upload, Simulate, ModifyNetlist)."}),"\n",(0,r.jsx)(n.h2,{id:"handler-functions",children:"Handler Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.set("upload")\r\ndef upload(data: Upload, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Processes schematic upload and dependency management."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Upload): Validated upload data containing schematic and dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Process:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Saves the schematic and dependencies to the project"}),"\n",(0,r.jsxs)(n.li,{children:["Calls ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),".upload() to extract netlist, parameters, components, and nets"]}),"\n",(0,r.jsx)(n.li,{children:"Returns a dictionary with the netlist, extracted data, and circuit graph"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.set("modify_netlist")\r\ndef modify_netlist(data: ModifyNetlist, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Replaces existing netlist with provided netlist data."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (ModifyNetlist): Validated netlist modification data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Process:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Replaces the existing netlist with the provided one"}),"\n",(0,r.jsxs)(n.li,{children:["Calls ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),".modify_netlist() and re-extracts metadata"]}),"\n",(0,r.jsx)(n.li,{children:"Returns the new netlist and associated metadata"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("extract_parameters")\r\ndef extract_parameters(data: Empty, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Extracts parameters from the current circuit netlist."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Empty): Empty data payload"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Dictionary with a list of parameters"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("extract_portables")\r\ndef extract_portables(data: Empty, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Extracts all portable elements including component types and models."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Empty): Empty data payload"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Dictionary with component metadata"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("simulate")\r\ndef simulate(data: Simulate, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Executes circuit simulation with provided parameters."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Simulate): Validated simulation configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Process:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Constructs a SimulationContext and runs a simulation"}),"\n",(0,r.jsx)(n.li,{children:"Returns the simulation result as provided by the backend"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("optimize")\r\ndef optimize(data: Simulate, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Executes circuit optimization with provided parameters."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Simulate): Validated simulation configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Process:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Similar to simulate, but enables optimization mode"}),"\n",(0,r.jsx)(n.li,{children:"Returns optimization results"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("extract_nets")\r\ndef extract_nets(data: Empty, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Extracts electrical network information from current circuit."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Empty): Empty data payload"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," List of all electrical nets in the current circuit"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("port")\r\ndef port(data: Port, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Ports netlist to new component mapping based on specified model."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Port): Validated port configuration data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Updated netlist and extracted metadata"]}),"\n",(0,r.jsx)(n.h2,{id:"dependency-management",children:"Dependency Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("deps")\r\ndef get_deps(data: GetCircuitDeps, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Lists all dependency files related to the given circuit."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (GetCircuitDeps): Circuit dependency query data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Nested dictionary representing the file structure"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.set("deps")\r\ndef add_dep(data: UploadCircuitDep, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Uploads and registers a new circuit dependency file."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (UploadCircuitDep): Base64-encoded file upload data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Process:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uploads a base64-encoded file and adds it as a dependency"}),"\n",(0,r.jsx)(n.li,{children:"Returns the updated dependency file structure"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.delete("deps")\r\ndef delete_dep(data: DeleteCircuitDep) -> None\n'})}),"\n",(0,r.jsx)(n.p,{children:"Removes specified circuit dependency file."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (DeleteCircuitDep): Dependency deletion specification"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," No content"]}),"\n",(0,r.jsx)(n.h2,{id:"graph-operations",children:"Graph Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'@router.get("extract_graph")\r\ndef extract_graph(data: Empty, strategy: SimInterface) -> dict\n'})}),"\n",(0,r.jsx)(n.p,{children:"Extracts graph representation of the current netlist."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data"})," (Empty): Empty data payload"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"strategy"})," (",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),"): Backend simulation strategy implementation"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Graph nodes and edges for visualization or analysis"]}),"\n",(0,r.jsx)(n.h2,{id:"design-principles",children:"Design Principles"}),"\n",(0,r.jsx)(n.h3,{id:"abstraction",children:"Abstraction"}),"\n",(0,r.jsxs)(n.p,{children:["The abstraction via ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"})," allows this module to support multiple backend simulators with minimal changes."]}),"\n",(0,r.jsx)(n.h3,{id:"reliability",children:"Reliability"}),"\n",(0,r.jsx)(n.p,{children:"All functions are structured to accept validated inputs and return consistent outputs, improving reliability."}),"\n",(0,r.jsx)(n.h3,{id:"separation-of-concerns",children:"Separation of Concerns"}),"\n",(0,r.jsx)(n.p,{children:"The handlers focus solely on routing and delegating logic, adhering to separation of concerns."}),"\n",(0,r.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pydantic models (Upload, Simulate, ModifyNetlist, Empty, Port, GetCircuitDeps, UploadCircuitDep, DeleteCircuitDep)"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"})," strategy pattern implementation"]}),"\n",(0,r.jsx)(n.li,{children:"SimulationContext for simulation execution"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);