"use strict";(self.webpackChunkuser_manual=self.webpackChunkuser_manual||[]).push([[9691],{7009:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"simpackage/spice/netlist-reader","title":"SpiceNetlistProcessor","description":"Provides multiple helper functions to work with spice netlists.","source":"@site/connectors/simpackage/spice/netlist-reader.md","sourceDirName":"simpackage/spice","slug":"/simpackage/spice/netlist-reader","permalink":"/connectors/simpackage/spice/netlist-reader","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"connectorsSidebar","previous":{"title":"Simulator","permalink":"/connectors/simpackage/simulatordomain"},"next":{"title":"Netlist Scope","permalink":"/connectors/simpackage/spice/netlistscope"}}');var t=s(4848),i=s(8453);const l={},a="SpiceNetlistProcessor",c={},d=[{value:"Attributes",id:"attributes",level:2},{value:"<strong>Constructor</strong>",id:"constructor",level:3},{value:"<strong>Netlist Output Methods</strong>",id:"netlist-output-methods",level:3},{value:"<strong>Subcircuit Management</strong>",id:"subcircuit-management",level:3},{value:"<strong>Parameter Management</strong>",id:"parameter-management",level:3},{value:"<strong>Component Extraction</strong>",id:"component-extraction",level:3},{value:"<strong>String Mangling Methods</strong>",id:"string-mangling-methods",level:3},{value:"<strong>Component Name Mangling</strong>",id:"component-name-mangling",level:3},{value:"<strong>Parameter Name Mangling</strong>",id:"parameter-name-mangling",level:3},{value:"<strong>Formal Parameter Mangling</strong>",id:"formal-parameter-mangling",level:3},{value:"<strong>Feature Name Mangling</strong>",id:"feature-name-mangling",level:3},{value:"<strong>Expression Processing</strong>",id:"expression-processing",level:3},{value:"<strong>Feature Extraction</strong>",id:"feature-extraction",level:3},{value:"<strong>Measurement Management</strong>",id:"measurement-management",level:3},{value:"<strong>Model Porting</strong>",id:"model-porting",level:3},{value:"<strong>Simulation Configuration</strong>",id:"simulation-configuration",level:3},{value:"<strong>Netlist Modification</strong>",id:"netlist-modification",level:3},{value:"<strong>File Operations</strong>",id:"file-operations",level:3},{value:"<strong>Graph Construction</strong>",id:"graph-construction",level:3},{value:"<strong>Utility Methods</strong>",id:"utility-methods",level:3}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"spicenetlistprocessor",children:"SpiceNetlistProcessor"})}),"\n",(0,t.jsx)(n.p,{children:"Provides multiple helper functions to work with spice netlists."}),"\n",(0,t.jsx)(n.h2,{id:"attributes",children:"Attributes"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Name"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Type"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Description"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SUBCKT_REGEX"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"str"})}),(0,t.jsxs)(n.td,{children:["Regex pattern to match ",(0,t.jsx)(n.code,{children:".subckt"})," definitions"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"COMPONENT_REGEX"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"str"})}),(0,t.jsx)(n.td,{children:"Regex pattern to match components"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"COMPONENT_PARAM_REGEX"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"str"})}),(0,t.jsx)(n.td,{children:"Regex for matching component parameters"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PARAM_REGEX"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"str"})}),(0,t.jsxs)(n.td,{children:["Regex for matching ",(0,t.jsx)(n.code,{children:".param"})," lines"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"COMPONENT_FEATURE_REGEX"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"str"})}),(0,t.jsx)(n.td,{children:"Regex for component features"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"spice_variant"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"spicevariants",children:"SPICEVariants"})}),(0,t.jsx)(n.td,{children:"Selected SPICE variant"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"master_netlist"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"str"})}),(0,t.jsx)(n.td,{children:"The original netlist content"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"netlist"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"str"})}),(0,t.jsx)(n.td,{children:"The working netlist content"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"netlist_lines"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"list[str]"})}),(0,t.jsx)(n.td,{children:"Netlist split into lines"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"component_lines"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"list[str]"})}),(0,t.jsx)(n.td,{children:"Extracted component lines"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"subckts"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dict[str, list[str]]"})}),(0,t.jsx)(n.td,{children:"Subcircuit definitions"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"subckt_ranges"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dict[str, range]"})}),(0,t.jsx)(n.td,{children:"Subcircuit ranges"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"non_component_lines"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"list[str]"})}),(0,t.jsx)(n.td,{children:"Lines not representing components"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"external_subckt_file_map"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dict[str, Path]"})}),(0,t.jsx)(n.td,{children:"Maps subcircuit name \u2192 file"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"external_file_subckt_map"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dict[Path, list[str]]"})}),(0,t.jsx)(n.td,{children:"Maps file \u2192 subcircuit list"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"includes"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dict[str, int]"})}),(0,t.jsx)(n.td,{children:"Included files with line index"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"libs"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dict[str, int]"})}),(0,t.jsx)(n.td,{children:"Libraries with line index"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"constructor",children:(0,t.jsx)(n.strong,{children:"Constructor"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def __init__(self, netlist_content: str, add_lines_at: int = -1, spice_variant: SPICEVariants = SPICEVariants.NGSpice) -> None\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"netlist_content"})," (str): The SPICE netlist content to process"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"add_lines_at"})," (int): Line position where new lines should be inserted (default: -1)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"spice_variant"})," (",(0,t.jsx)(n.a,{href:"spicevariants",children:"SPICEVariants"}),"): The SPICE simulator variant to use (default: NGSpice)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Initializes the netlist processor with the given content and configuration. Parses the netlist and sets up internal data structures for processing."]}),"\n",(0,t.jsx)(n.h3,{id:"netlist-output-methods",children:(0,t.jsx)(n.strong,{children:"Netlist Output Methods"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def get_sanitized(self) -> str\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Returns a sanitized version of the final netlist with paths cleaned according to the platform-specific regex patterns."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def get_final_netlist(self)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Applies all pending changes and returns the final netlist as encoded bytes using the configured encoding."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def write_netlist(self, path: str | Path)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"path"})," (str | Path): File path where the netlist should be written\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Writes the final netlist to the specified file path."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"subcircuit-management",children:(0,t.jsx)(n.strong,{children:"Subcircuit Management"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def attach_subckt(self, path: Path)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"path"})," (Path): Path to the subcircuit file to attach\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Reads and attaches a subcircuit file to the netlist processor, making its definitions available for use."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"parameter-management",children:(0,t.jsx)(n.strong,{children:"Parameter Management"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def get_all_design_parameters(self) -> dict[str, str]\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Extracts all design parameters from the netlist, including those from subcircuits, and returns them as a dictionary mapping parameter names to their values."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def get_param_value_range(self, value: str, *, min_scale: float = 0.5, max_scale: float = 1.0, default_min: float = 1000, default_max: float = 10000)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"})," (str): The parameter value to analyze"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"min_scale"})," (float): Scale factor for minimum value (default: 0.5)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"max_scale"})," (float): Scale factor for maximum value (default: 1.0)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"default_min"})," (float): Default minimum if parsing fails (default: 1000)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"default_max"})," (float): Default maximum if parsing fails (default: 10000)\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Returns a tuple of (min, max) values for the given parameter value, with configurable scaling factors."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def get_referencing_components(self, parameters: list[str]) -> dict[str, list[str]]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"parameters"})," (list[str]): List of parameter names to find references for\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Finds all components that reference the specified parameters and returns a mapping from parameter names to lists of component names."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def set_parameter(self, param: str, value: str, location: str | None = None)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"param"})," (str): Parameter name to set"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"})," (str): New value for the parameter"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"location"})," (str | None): Circuit location where the parameter should be set (default: None for main circuit)\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Sets a specific parameter value in the netlist, either by replacing an existing parameter or adding a new one."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def set_parameters(self, **kwargs)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"**kwargs"}),": Keyword arguments where keys are parameter names and values are parameter values\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Sets multiple parameters at once using keyword arguments."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"component-extraction",children:(0,t.jsx)(n.strong,{children:"Component Extraction"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def extract_components(self) -> list[str]\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Extracts all component names from the main circuit and returns them as a list."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def extract_component_types(self) -> list[str]\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Extracts all unique component types from the main circuit and returns them as a list."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def extract_component_models(self) -> list[str]\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Extracts all unique model names used by components in the main circuit and returns them as a list."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def extract_nets(self) -> dict[str, list[str]]\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Extracts all nets and their connections from the main circuit, returning a dictionary mapping component names to their connection lists."]}),"\n",(0,t.jsx)(n.h3,{id:"string-mangling-methods",children:(0,t.jsx)(n.strong,{children:"String Mangling Methods"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def mangle_str_chain(self, str_chain: list[str], seperator: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"str_chain"})," (list[str]): List of strings to mangle"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"seperator"})," (str): Separator to use between mangled strings\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Combines a list of strings into a single mangled string using the specified separator."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def unmangle_str_chain(self, mangled_str_chain: str, seperator: str) -> list[str]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mangled_str_chain"})," (str): The mangled string to unmangle"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"seperator"})," (str): Separator used in the mangled string\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Splits a mangled string back into a list of strings using the specified separator."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"component-name-mangling",children:(0,t.jsx)(n.strong,{children:"Component Name Mangling"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def mangle_component_name(self, instance_scope: list[str], component_name: str) -> str\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instance_scope"})," (list[str]): The instance scope hierarchy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"component_name"})," (str): The component name to mangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Creates a mangled component name that includes the instance scope information."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def unmangle_component_name(self, mangled_name: str) -> tuple[list[str], str]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mangled_name"})," (str): The mangled component name to unmangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Extracts the instance scope and component name from a mangled component name."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"parameter-name-mangling",children:(0,t.jsx)(n.strong,{children:"Parameter Name Mangling"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def mangle_param_name(self, definition_scope: str, param_name: str) -> str\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"definition_scope"})," (str): The definition scope"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"param_name"})," (str): The parameter name to mangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Creates a mangled parameter name that includes the definition scope information."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def unmangle_param_name(self, mangled_name: str) -> tuple[str, str]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mangled_name"})," (str): The mangled parameter name to unmangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Extracts the definition scope and parameter name from a mangled parameter name."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"formal-parameter-mangling",children:(0,t.jsx)(n.strong,{children:"Formal Parameter Mangling"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def mangle_formal_param_name(self, instance_scope: list[str], param_name: str) -> str\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instance_scope"})," (list[str]): The instance scope hierarchy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"param_name"})," (str): The formal parameter name to mangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Creates a mangled formal parameter name that includes the instance scope information."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def unmangle_formal_param_name(self, mangled_name: str) -> tuple[list[str], str]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mangled_name"})," (str): The mangled formal parameter name to unmangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Extracts the instance scope and formal parameter name from a mangled formal parameter name."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"feature-name-mangling",children:(0,t.jsx)(n.strong,{children:"Feature Name Mangling"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def mangle_feature_name(self, instance_scope: list[str], feature_name: str) -> str\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instance_scope"})," (list[str]): The instance scope hierarchy"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"feature_name"})," (str): The feature name to mangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Creates a mangled feature name that includes the instance scope information."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def unmangle_feature_name(self, mangled_name: str) -> tuple[list[str], str]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mangled_name"})," (str): The mangled feature name to unmangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Extracts the instance scope and feature name from a mangled feature name."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"expression-processing",children:(0,t.jsx)(n.strong,{children:"Expression Processing"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def mangle_expression(self, instance_referrables: dict, definition_referrables: dict, expression: str) -> str\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instance_referrables"})," (dict): Dictionary of instance-level referrable parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"definition_referrables"})," (dict): Dictionary of definition-level referrable parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"expression"})," (str): The expression to mangle\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Processes an expression by mangling parameter references according to the provided referrable dictionaries."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"feature-extraction",children:(0,t.jsx)(n.strong,{children:"Feature Extraction"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def add_feature_extraction(self)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Adds feature extraction capabilities to the netlist by adding parameter tracing and measurement statements."]}),"\n",(0,t.jsx)(n.h3,{id:"measurement-management",children:(0,t.jsx)(n.strong,{children:"Measurement Management"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def add_measurement_statements(self, measurement: Measurement)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"measurement"})," (Measurement): The measurement configuration to add\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Adds measurement statements to the netlist based on the provided measurement configuration."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"model-porting",children:(0,t.jsx)(n.strong,{children:"Model Porting"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def port_model(self, src: str, target: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src"})," (str): Source model name"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"})," (str): Target model name\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Replaces all instances of the source model with the target model in the netlist."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def port_component_type(self, component_type: Components, target: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"component_type"})," (Components): The component type to port"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"})," (str): Target model name\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Replaces all models of the specified component type with the target model."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def port_component(self, component_identifier: str, target: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"component_identifier"})," (str): The specific component identifier to port"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"})," (str): Target model name\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Replaces the model of the specified component with the target model."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"simulation-configuration",children:(0,t.jsx)(n.strong,{children:"Simulation Configuration"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def set_temperature(self, value: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"})," (str): Temperature value to set\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Adds a temperature setting to the netlist."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def add_include_file(self, path: str | Path)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"path"})," (str | Path): Path to the file to include\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Adds an include statement to the netlist."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def add_lib_file(self, path: str | Path, lib_name: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"path"})," (str | Path): Path to the library file"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"lib_name"})," (str): Name of the library\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Adds a library file reference to the netlist."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def add_raw_file(self, name: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"name"})," (str): Name for the raw output file\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Adds a raw file output command to the netlist."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def update_lib_argument(self, lib_name: str, argument: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"lib_name"})," (str): Name of the library to update"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"argument"})," (str): New argument for the library\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Updates the argument of a library reference in the netlist."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"netlist-modification",children:(0,t.jsx)(n.strong,{children:"Netlist Modification"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def modify(self, new_netlist: str) -> str\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"new_netlist"})," (str): The new netlist content\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Modifies the current netlist by comparing it with the new netlist and applying differences."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def reset(self)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Resets the netlist to its original state and reapplies all changes."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def apply_changes(self)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Applies all pending changes (additions, replacements, deletions) to the netlist and re-parses it."]}),"\n",(0,t.jsx)(n.h3,{id:"file-operations",children:(0,t.jsx)(n.strong,{children:"File Operations"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def write_all_subckts(self)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Writes all external subcircuit files to disk with their current content."]}),"\n",(0,t.jsx)(n.h3,{id:"graph-construction",children:(0,t.jsx)(n.strong,{children:"Graph Construction"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def construct_subcircuit_graph(self, parent_name: str) -> MultiDiGraph\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"parent_name"})," (str): Name of the parent subcircuit\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Constructs a NetworkX graph representation of the specified subcircuit."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def construct_graph(self) -> dict\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Description:"})," Constructs a complete graph representation of the entire netlist and returns it as a JSON-serializable dictionary."]}),"\n",(0,t.jsx)(n.h3,{id:"utility-methods",children:(0,t.jsx)(n.strong,{children:"Utility Methods"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def normalize(self, value: NormType, mode: str = "lower") -> NormType\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"})," (NormType): Value to normalize"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mode"}),' (str): Normalization mode ("lower" or "upper", default: "lower")\r\n',(0,t.jsx)(n.strong,{children:"Description:"})," Normalizes strings, dictionaries, sets, or lists by converting them to lowercase or uppercase according to the specified mode."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def process_subckt_graph(self, subckt_graph: MultiDiGraph, mapping: dict[str, str], instance_name: str)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"subckt_graph"})," (MultiDiGraph): The subcircuit graph to process"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mapping"})," (dict[str, str]): Mapping of node names"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instance_name"})," (str): Name of the instance\r\n",(0,t.jsx)(n.strong,{children:"Description:"})," Processes a subcircuit graph by applying node mappings and instance name prefixes."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var r=s(6540);const t={},i=r.createContext(t);function l(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);