"use strict";(self.webpackChunkuser_manual=self.webpackChunkuser_manual||[]).push([[6812],{4727:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"simpackage/slim-models","title":"Connector Models","description":"The Connector Models module defines Pydantic models used for managing connector-related functionality such as uploads, netlist modifications, dependency management, simulation setup, and data capture. These models enforce structure and validation for data exchanged between the frontend, backend, and simulation engine.","source":"@site/connectors/simpackage/slim-models.md","sourceDirName":"simpackage","slug":"/simpackage/slim-models","permalink":"/connectors/simpackage/slim-models","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"connectorsSidebar","previous":{"title":"Router Handlers","permalink":"/connectors/simpackage/simcontroller"},"next":{"title":"SimInterface","permalink":"/connectors/simpackage/siminterface"}}');var r=s(4848),t=s(8453);const l={},d="Connector Models",o={},a=[{value:"Module Definition",id:"module-definition",level:2},{value:"Base Models",id:"base-models",level:2},{value:"Base",id:"base",level:3},{value:"Empty",id:"empty",level:3},{value:"Dependency Models",id:"dependency-models",level:2},{value:"Dep",id:"dep",level:3},{value:"UploadCircuitDep",id:"uploadcircuitdep",level:3},{value:"DeleteCircuitDep",id:"deletecircuitdep",level:3},{value:"GetCircuitDeps",id:"getcircuitdeps",level:3},{value:"Schematic and Netlist Models",id:"schematic-and-netlist-models",level:2},{value:"Upload",id:"upload",level:3},{value:"ModifyNetlist",id:"modifynetlist",level:3},{value:"Port and Mapping Models",id:"port-and-mapping-models",level:2},{value:"Port",id:"port",level:3},{value:"Simulation Dependency Models",id:"simulation-dependency-models",level:2},{value:"SimulationDep",id:"simulationdep",level:3},{value:"ProcessCorner",id:"processcorner",level:3},{value:"Data Capture and Sweep Models",id:"data-capture-and-sweep-models",level:2},{value:"DataCapture",id:"datacapture",level:3},{value:"SweepGroup",id:"sweepgroup",level:3},{value:"Simulation Context Models",id:"simulation-context-models",level:2},{value:"SimulationContext",id:"simulationcontext",level:3},{value:"Simulate",id:"simulate",level:3},{value:"Model Hierarchy",id:"model-hierarchy",level:2},{value:"Dependencies",id:"dependencies",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"connector-models",children:"Connector Models"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"slim-models",children:"Connector Models"})," module defines Pydantic models used for managing connector-related functionality such as uploads, netlist modifications, dependency management, simulation setup, and data capture. These models enforce structure and validation for data exchanged between the frontend, backend, and simulation engine."]}),"\n",(0,r.jsx)(n.h2,{id:"module-definition",children:"Module Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Connector Models - Pydantic Data Validation\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Structure and validation for data exchanged between frontend, backend, and simulation engine."]}),"\n",(0,r.jsx)(n.h2,{id:"base-models",children:"Base Models"}),"\n",(0,r.jsx)(n.h3,{id:"base",children:"Base"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Base(BaseModel):\r\n    project_id: str\r\n    artifact_id: str\n"})}),"\n",(0,r.jsx)(n.p,{children:"Base model for all connector payloads containing project and artifact identification."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"project_id"})," (str): Identifier for the project"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"artifact_id"})," (str): Identifier for the specific artifact within the project"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"empty",children:"Empty"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Empty(Base):\r\n    pass\n"})}),"\n",(0,r.jsx)(n.p,{children:"An empty placeholder derived from Base for requests that do not require additional payload data."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," Base"]}),"\n",(0,r.jsx)(n.h2,{id:"dependency-models",children:"Dependency Models"}),"\n",(0,r.jsx)(n.h3,{id:"dep",children:"Dep"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Dep(BaseModel):\r\n    dep_name: str\r\n    dep_contents: str\r\n    dep_kind: CircuitDepTypes\n"})}),"\n",(0,r.jsx)(n.p,{children:"Represents a circuit dependency with validation."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_name"})," (str): Name of the dependency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_contents"})," (str): Contents (code/data) of the dependency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_kind"})," (CircuitDepTypes): Enum value describing the type of circuit dependency"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Validation:"}),"\r\nIncludes a custom validator to convert raw values to CircuitDepTypes."]}),"\n",(0,r.jsx)(n.h3,{id:"uploadcircuitdep",children:"UploadCircuitDep"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class UploadCircuitDep(Base, Dep):\r\n    pass\n"})}),"\n",(0,r.jsx)(n.p,{children:"Model for uploading a circuit dependency with project/artifact context."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," Base, Dep"]}),"\n",(0,r.jsx)(n.h3,{id:"deletecircuitdep",children:"DeleteCircuitDep"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class DeleteCircuitDep(Base):\r\n    dep_name: str\r\n    dep_kind: CircuitDepTypes\n"})}),"\n",(0,r.jsx)(n.p,{children:"Model for deleting a specific circuit dependency by name and kind."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_name"})," (str): Name of the dependency to delete"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_kind"})," (CircuitDepTypes): Type of dependency to delete"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," Base"]}),"\n",(0,r.jsx)(n.h3,{id:"getcircuitdeps",children:"GetCircuitDeps"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class GetCircuitDeps(BaseModel):\r\n    dep_kind: CircuitDepTypes\n"})}),"\n",(0,r.jsx)(n.p,{children:"Request model for fetching circuit dependencies by type."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_kind"})," (CircuitDepTypes): Type of dependencies to retrieve"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"schematic-and-netlist-models",children:"Schematic and Netlist Models"}),"\n",(0,r.jsx)(n.h3,{id:"upload",children:"Upload"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Upload(Base):\r\n    schematic: str\r\n    extension: str\r\n    deps: list[Dep]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Model representing a schematic file and its dependencies for upload."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"schematic"})," (str): Base64-encoded schematic content"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"extension"})," (str): File type (e.g., .sch, .ckt)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"deps"})," (list[Dep]): List of associated dependencies"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," Base"]}),"\n",(0,r.jsx)(n.h3,{id:"modifynetlist",children:"ModifyNetlist"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ModifyNetlist(Base):\r\n    netlist: str\n"})}),"\n",(0,r.jsx)(n.p,{children:"Model for updating or modifying netlist content."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"netlist"})," (str): New netlist content"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," Base"]}),"\n",(0,r.jsx)(n.h2,{id:"port-and-mapping-models",children:"Port and Mapping Models"}),"\n",(0,r.jsx)(n.h3,{id:"port",children:"Port"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Port(Base):\r\n    mapping: str\r\n    device_model_paths: list[str]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Model for mapping ports to device models."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mapping"})," (str): Port mapping specification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"device_model_paths"})," (list[str]): List of paths to device models"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," Base"]}),"\n",(0,r.jsx)(n.h2,{id:"simulation-dependency-models",children:"Simulation Dependency Models"}),"\n",(0,r.jsx)(n.h3,{id:"simulationdep",children:"SimulationDep"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class SimulationDep(BaseModel):\r\n    dep_name: str\r\n    dep_kind: CircuitDepTypes\r\n    args: str = ""\n'})}),"\n",(0,r.jsx)(n.p,{children:"Defines an additional dependency required during simulation."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_name"})," (str): Name of the dependency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dep_kind"})," (CircuitDepTypes): Kind of dependency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"args"}),' (str): Optional command-line or simulation-specific arguments (default: "")']}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"processcorner",children:"ProcessCorner"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ProcessCorner(BaseModel):\r\n    portable: str\r\n    model_name: str\r\n    kind: PortLocation\n"})}),"\n",(0,r.jsx)(n.p,{children:"Describes a process corner used in simulation."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"portable"})," (str): Identifier for the corner configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"model_name"})," (str): Name of the associated model"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"kind"})," (PortLocation): Enum value representing port location (e.g., typical, slow)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"data-capture-and-sweep-models",children:"Data Capture and Sweep Models"}),"\n",(0,r.jsx)(n.h3,{id:"datacapture",children:"DataCapture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class DataCapture(BaseModel):\r\n    name: str\r\n    index: int\n"})}),"\n",(0,r.jsx)(n.p,{children:"Defines a probe or point for capturing simulation data."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"})," (str): Name of the capture point"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"index"})," (int): Index or position of the capture point"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sweepgroup",children:"SweepGroup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class SweepGroup(BaseModel):\r\n    name: str\r\n    depth: int\r\n    parameters: list[str]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Specifies a group of sweep parameters for parametric analysis."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"})," (str): Group name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"depth"})," (int): Nesting level for the sweep"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"parameters"})," (list[str]): List of parameter names involved in the sweep"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"simulation-context-models",children:"Simulation Context Models"}),"\n",(0,r.jsx)(n.h3,{id:"simulationcontext",children:"SimulationContext"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class SimulationContext(BaseModel):\r\n    parameters: dict[str, str | list[str]] = {}\r\n    sweep_groups: list[SweepGroup] = []\r\n    temperature: str | None = None\r\n    instructions: dict | None = None\r\n    data_capture: list[DataCapture] = []\r\n    deps: list[SimulationDep] | None = None\r\n    process_corners: list[ProcessCorner] | None = None\n"})}),"\n",(0,r.jsx)(n.p,{children:"Comprehensive model defining the entire simulation environment."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"parameters"})," (dict[str, str | list[str]]): Simulation parameters (default: ",")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"sweep_groups"})," (list[SweepGroup]): Parameter sweep definitions (default: [])"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"temperature"})," (str | None): Simulation temperature (default: None)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"instructions"})," (dict | None): Additional simulation instructions (default: None)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"data_capture"})," (list[DataCapture]): Points for data capture (default: [])"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"deps"})," (list[SimulationDep] | None): Simulation dependencies (default: None)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"process_corners"})," (list[ProcessCorner] | None): Process corner specifications (default: None)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"simulate",children:"Simulate"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Simulate(Base, SimulationContext):\r\n    run_id: str | None\r\n    extract_features: bool = False\n"})}),"\n",(0,r.jsx)(n.p,{children:"Model extending Base and SimulationContext to initiate a simulation run."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"run_id"})," (str | None): Optional identifier for tracking the run"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"extract_features"})," (bool): Flag to extract model features post-simulation (default: False)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," Base, SimulationContext"]}),"\n",(0,r.jsx)(n.h2,{id:"model-hierarchy",children:"Model Hierarchy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"BaseModel (Pydantic)\r\n\u251c\u2500\u2500 Base\r\n\u2502   \u251c\u2500\u2500 Empty\r\n\u2502   \u251c\u2500\u2500 UploadCircuitDep (also inherits Dep)\r\n\u2502   \u251c\u2500\u2500 DeleteCircuitDep\r\n\u2502   \u251c\u2500\u2500 Upload\r\n\u2502   \u251c\u2500\u2500 ModifyNetlist\r\n\u2502   \u251c\u2500\u2500 Port\r\n\u2502   \u2514\u2500\u2500 Simulate (also inherits SimulationContext)\r\n\u251c\u2500\u2500 Dep\r\n\u251c\u2500\u2500 GetCircuitDeps\r\n\u251c\u2500\u2500 SimulationDep\r\n\u251c\u2500\u2500 ProcessCorner\r\n\u251c\u2500\u2500 DataCapture\r\n\u251c\u2500\u2500 SweepGroup\r\n\u2514\u2500\u2500 SimulationContext\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"BaseModel from pydantic"}),"\n",(0,r.jsx)(n.li,{children:"CircuitDepTypes (dependency type enumeration)"}),"\n",(0,r.jsx)(n.li,{children:"PortLocation (port location enumeration)"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var i=s(6540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);