"use strict";(self.webpackChunkuser_manual=self.webpackChunkuser_manual||[]).push([[4610],{2743:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"simpackage/siminterface","title":"SimInterface","description":"The SimInterface class is an abstract base class that defines the interface contract for a simulator connector in the system. It extends ConnectorSpec and enforces implementation of core simulation capabilities such as netlist creation, parameter extraction, simulation execution, and component/model handling.","source":"@site/connectors/simpackage/siminterface.md","sourceDirName":"simpackage","slug":"/simpackage/siminterface","permalink":"/connectors/simpackage/siminterface","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"connectorsSidebar","previous":{"title":"Connector Models","permalink":"/connectors/simpackage/slim-models"},"next":{"title":"Simulator","permalink":"/connectors/simpackage/simulatordomain"}}');var r=t(4848),a=t(8453);const i={},l="SimInterface",c={},d=[{value:"Class Definition",id:"class-definition",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Abstract Methods",id:"abstract-methods",level:2},{value:"Concrete Methods",id:"concrete-methods",level:2},{value:"Required Subclass Implementation",id:"required-subclass-implementation",level:2},{value:"Dependencies",id:"dependencies",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"siminterface",children:"SimInterface"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"})," class is an abstract base class that defines the interface contract for a simulator connector in the system. It extends ConnectorSpec and enforces implementation of core simulation capabilities such as netlist creation, parameter extraction, simulation execution, and component/model handling."]}),"\n",(0,r.jsx)(n.h2,{id:"class-definition",children:"Class Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class SimInterface(ConnectorSpec, ABC):\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Inherits from:"})," ConnectorSpec, ABC (Abstract Base Class)"]}),"\n",(0,r.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"})," class inherits its constructor from ConnectorSpec and does not define additional initialization parameters."]}),"\n",(0,r.jsx)(n.h2,{id:"abstract-methods",children:"Abstract Methods"}),"\n",(0,r.jsxs)(n.p,{children:["The following methods ",(0,r.jsx)(n.strong,{children:"must"})," be implemented by all subclasses of ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef create_netlist(self, metadata: Metadata) -> bytes\n"})}),"\n",(0,r.jsx)(n.p,{children:"Generate a raw netlist representation from the given metadata."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata containing component and connection information"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Raw netlist as bytes"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef modify_netlist(self, netlist: str, metadata: Metadata) -> bytes\n"})}),"\n",(0,r.jsx)(n.p,{children:"Apply modifications to an existing netlist based on updated metadata."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"netlist"})," (str): Existing netlist content"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Updated metadata with modifications"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Modified netlist as bytes"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef get_parameters(self, metadata: Metadata) -> dict\n"})}),"\n",(0,r.jsx)(n.p,{children:"Extract simulation-relevant parameters from the circuit metadata."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Dictionary of simulation parameters"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef run_simulation(self, simulation_ctx: SimulationContext, metadata: Metadata) -> dict\n"})}),"\n",(0,r.jsx)(n.p,{children:"Run a simulation using the provided context and return results."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"simulation_ctx"})," (SimulationContext): Simulation configuration and context"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Dictionary containing simulation results"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef get_nets(self, metadata: Metadata) -> dict\n"})}),"\n",(0,r.jsx)(n.p,{children:"Extract all signal nets (connections) from the circuit graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Dictionary of circuit nets and connections"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef port(self, mapping: str, models: list[str], metadata: Metadata) -> bytes\n"})}),"\n",(0,r.jsx)(n.p,{children:"Produce a portable (e.g., SPICE-compatible) representation using a model mapping."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"mapping"})," (str): Model mapping specification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"models"})," (list[str]): List of available models"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Portable netlist representation as bytes"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef get_components(self, metadata: Metadata) -> list[str]\n"})}),"\n",(0,r.jsx)(n.p,{children:"List all components present in the circuit."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," List of component identifiers"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef get_models(self, metadata: Metadata) -> list[str]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Return a list of supported or available simulation models."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," List of available simulation models"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef get_component_types(self, metadata: Metadata) -> list[str]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Classify components into types (e.g., resistors, capacitors)."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," List of component type classifications"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"@abstractmethod\r\ndef get_graph(self, metadata: Metadata) -> dict\n"})}),"\n",(0,r.jsx)(n.p,{children:"Return the circuit graph (e.g., nodes, connections) in a structured format."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Dictionary representing circuit graph structure"]}),"\n",(0,r.jsx)(n.h2,{id:"concrete-methods",children:"Concrete Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def get_portables(self, metadata: Metadata) -> tuple[list[str], list[str], list[str]]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Helper method to retrieve components, component types, and models in one call."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Tuple containing (components, component_types, models)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def available_deps(self, path: Path) -> dict[str, Any]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Recursively scans the given path and builds a dictionary representing the file/folder structure."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"path"})," (Path): Directory path to scan"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Dictionary representing file structure"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example Structure:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'{\r\n  "subfolder": {\r\n      "file.txt": "subfolder/file.txt"\r\n  },\r\n  ...\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def upload(self, metadata: Metadata) -> dict\n"})}),"\n",(0,r.jsx)(n.p,{children:"Prepares a dictionary payload of all simulation metadata required for registration or upload."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"metadata"})," (Metadata): Circuit metadata"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Includes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Base64-encoded netlist"}),"\n",(0,r.jsx)(n.li,{children:"Parameters"}),"\n",(0,r.jsx)(n.li,{children:"Nets"}),"\n",(0,r.jsx)(n.li,{children:"Components & types"}),"\n",(0,r.jsx)(n.li,{children:"Dependency graph"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Complete metadata dictionary for upload"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def add_dep(self, project: str, kind: CircuitDepTypes, name: str, contents: str) -> Path\n"})}),"\n",(0,r.jsx)(n.p,{children:"Adds a dependency (e.g., model or library file) to the connector's data directory."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"project"})," (str): Project name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"kind"})," (CircuitDepTypes): Enum of dependency type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"})," (str): File name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"contents"})," (str): Base64-encoded file content"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Path where the file was saved"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def call(self, request: str, *args, **kwargs) -> Any\n"})}),"\n",(0,r.jsx)(n.p,{children:"Dispatch method for dynamic method invocation by name."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"request"})," (str): Method name to invoke"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"args"}),": Positional arguments for the method"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"kwargs"}),": Keyword arguments for the method"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Supported Requests:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"netlist"'}),"\n",(0,r.jsx)(n.li,{children:'"modify_netlist"'}),"\n",(0,r.jsx)(n.li,{children:'"extract_parameters"'}),"\n",(0,r.jsx)(n.li,{children:'"extract_components"'}),"\n",(0,r.jsx)(n.li,{children:'"extract_nets"'}),"\n",(0,r.jsx)(n.li,{children:'"simulate" or "optimize"'}),"\n",(0,r.jsx)(n.li,{children:'"extract_graph"'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," Result from the invoked method"]}),"\n",(0,r.jsx)(n.h2,{id:"required-subclass-implementation",children:"Required Subclass Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["Any subclass of ",(0,r.jsx)(n.a,{href:"siminterface",children:"SimInterface"})," must implement all abstract methods:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class MySpiceSimulator(SimInterface):\r\n    def create_netlist(self, metadata):\r\n        ...\r\n    \r\n    def modify_netlist(self, netlist, metadata):\r\n        ...\r\n    \r\n    def get_parameters(self, metadata):\r\n        ...\r\n    \r\n    def run_simulation(self, simulation_ctx, metadata):\r\n        ...\r\n    \r\n    def get_nets(self, metadata):\r\n        ...\r\n    \r\n    def port(self, mapping, models, metadata):\r\n        ...\r\n    \r\n    def get_components(self, metadata):\r\n        ...\r\n    \r\n    def get_models(self, metadata):\r\n        ...\r\n    \r\n    def get_component_types(self, metadata):\r\n        ...\r\n    \r\n    def get_graph(self, metadata):\r\n        ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"ConnectorSpec (base class)"}),"\n",(0,r.jsx)(n.li,{children:"ABC (Abstract Base Class)"}),"\n",(0,r.jsx)(n.li,{children:"Metadata (circuit metadata structure)"}),"\n",(0,r.jsx)(n.li,{children:"SimulationContext (simulation configuration)"}),"\n",(0,r.jsx)(n.li,{children:"CircuitDepTypes (dependency type enumeration)"}),"\n",(0,r.jsx)(n.li,{children:"Path (file system path handling)"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);