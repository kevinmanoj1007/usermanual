"use strict";(self.webpackChunkuser_manual=self.webpackChunkuser_manual||[]).push([[4854],{7896:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"API/agent-interface","title":"AgentInterface","description":"Abstract class to define interacting with a purely RL agent.","source":"@site/adk/API/agent-interface.md","sourceDirName":"API","slug":"/API/agent-interface","permalink":"/adk/API/agent-interface","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"AgentInterface"},"sidebar":"tutorialSidebar","previous":{"title":"API","permalink":"/adk/category/api"},"next":{"title":"BaseAgent","permalink":"/adk/API/base-agent"}}');var i=s(4848),t=s(8453);const l={sidebar_position:1,title:"AgentInterface"},d="class AgentInterface",a={},c=[{value:"Import",id:"import",level:2},{value:"Methods",id:"methods",level:2},{value:"compute_action",id:"compute_action",level:3},{value:"experience",id:"experience",level:3},{value:"learn",id:"learn",level:3},{value:"save_models",id:"save_models",level:3},{value:"load_models",id:"load_models",level:3},{value:"sample_env_parameters",id:"sample_env_parameters",level:3},{value:"transfer_nn_arch",id:"transfer_nn_arch",level:3},{value:"transfer_specifics",id:"transfer_specifics",level:3},{value:"transfer_models",id:"transfer_models",level:3}];function o(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"class-agentinterface",children:"class AgentInterface"})}),"\n",(0,i.jsx)(n.p,{children:"Abstract class to define interacting with a purely RL agent."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ObservationType"})," and ",(0,i.jsx)(n.code,{children:"ActionType"})," types are ",(0,i.jsx)(n.code,{children:"TypeVar"}),"s because the actual types depend on\r\nthe context."]})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["There should be no visible side effects in the operation of an agent after an agent is saved and\r\nsubsequently loaded with ",(0,i.jsx)(n.code,{children:"save_models"})," and ",(0,i.jsx)(n.code,{children:"load_models"})," respectively. A loaded model must be a\r\n1:1 reconstruction of the respective saved model from an external API's point of view."]})}),"\n",(0,i.jsx)(n.h1,{id:"definition",children:"Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"class AgentInterface(ABC):\r\n    @abstractmethod\r\n    def compute_action(self, observation: ObservationType, info: dict[str, Any]) -> ActionType: pass\r\n\r\n    @abstractmethod\r\n    def experience(\r\n        self,\r\n        observation: ObservationType,\r\n        action: ActionType,\r\n        reward: SupportsFloat,\r\n        next_observation: ObservationType,\r\n        terminated: bool,\r\n        truncated: bool,\r\n        info: dict[str, Any],\r\n        next_info: dict[str, Any]\r\n    ) -> None: pass\r\n\r\n    @abstractmethod\r\n    def learn(self) -> None: pass\r\n\r\n    @abstractmethod\r\n    def save_models(self, save_to: Path) -> None: pass\r\n\r\n    @abstractmethod\r\n    def load_models(self, load_from: Path) -> None: pass\r\n\r\n    @abstractmethod\r\n    def sample_env_parameters(self) -> list: pass\n"})}),"\n",(0,i.jsx)(n.h2,{id:"import",children:"Import"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"from adk.agent_interface import AgentInterface\n"})}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"compute_action",children:"compute_action"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Compute an action based on an ",(0,i.jsx)(n.code,{children:"observation"})," and some ",(0,i.jsx)(n.code,{children:"info"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Takes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"observation: ObservationType"}),": The observation from the environment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"info: dict[str, Any]"}),": Auxiliary diagnostic information for the agent (helpful for\r\ndebugging, learning, and logging). This might, for instance, contain: metrics that describe\r\nthe agent\u2019s performance state, variables that are hidden from observations, or individual\r\nreward terms that are combined to produce the total reward."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"action: ActionType"}),": Action taken based on the ",(0,i.jsx)(n.code,{children:"observation"})," and ",(0,i.jsx)(n.code,{children:"info"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"@abstractmethod\r\ndef compute_action(self, observation: ObservationType, info: dict[str, Any]) -> ActionType: pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"experience",children:"experience"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Append one iteration of the RL ",(0,i.jsx)(n.code,{children:"sars'd"})," loop to the agent's experiences.\r\nThis method is guaranteed to be called exactly once right after ",(0,i.jsx)(n.code,{children:"compute_action"})," is called."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Takes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"observation: ObservationType"}),": The original observation from the environment,"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"action: ActionType"}),": The action taken based on the original observation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"reward: SupportsFloat"}),": The reward for the action which was taken based on the original observation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"next_observation: ObservationType"}),": The observation obtained after taking the action\r\nbased on the original observation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"terminated: bool"}),": Whether or not the episode ",(0,i.jsx)(n.strong,{children:"terminated"})," (ended by satisfying the task\r\n/ target) after taking the action based on the original observation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"truncated: bool"}),": Whether or not the episode ",(0,i.jsx)(n.strong,{children:"truncated"})," (ended by triggering a boundary\r\ncondition / limit) after taking the action based on the original observation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"info: dict[str, Any]"}),": The original auxiliary diagnostic information."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"next_info: dict[str, Any]"}),": The auxiliary diagnostic information obtained after taking\r\nthe action based on the original observation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Returns: Nothing"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"@abstractmethod\r\ndef experience(self, observation: ObservationType, action: ActionType, reward: SupportsFloat, next_observation: ObservationType, terminated: bool, truncated: bool, info: dict[str, Any], next_info: dict[str, Any]) -> None: pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"learn",children:"learn"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": The agent's internal learn routine. e.g. An RL algorithm using collected\r\nexperiences to train in order to improve performance. This method is guaranteed to be called\r\nexactly once right after ",(0,i.jsx)(n.code,{children:"experience"})," is called."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Takes: Nothing"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Returns: Nothing"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"@abstractmethod\r\ndef learn(self) -> None: pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"save_models",children:"save_models"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Save the agent's internal state to the specified path on the filesystem."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Takes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"save_to: Path"}),": The filesystem path to which the state is to be saved."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Returns: Nothing"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"@abstractmethod\r\ndef save_models(self, save_to: Path) -> None: pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"load_models",children:"load_models"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Load the agent's internal state from the specified path on the filesystem."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Takes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"load_from: Path"}),": The filesystem path from which the state is to be loaded."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Returns: Nothing"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"@abstractmethod\r\ndef load_models(self, load_from: Path) -> None: pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"sample_env_parameters",children:"sample_env_parameters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Sample stochastic parameters (sampled based on nothing other than\r\na predefined sampling scheme.)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Takes: Nothing"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"env_parameters: list"}),": Randomly sampled stochastic parameters."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"@abstractmethod\r\ndef sample_env_parameters(self) -> list: pass\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Note that stochastically / randomly sampled does not necessarily mean sampled from a\r\nuniform distribution."})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"transfer_nn_arch",children:"transfer_nn_arch"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Transfer a neural network architecture from a source ",(0,i.jsx)(n.code,{children:"GenieModel"})," using the provided ",(0,i.jsx)(n.code,{children:"TransferModel"})," and existing architecture dictionary."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Takes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_genie_model: GenieModel"}),": The source model from which the architecture is being transferred."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer_data: TransferModel"}),": The data structure containing parameters and rules for the transfer process."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_nn_arch: dict"}),": The existing neural network architecture dictionary to be used as the base for transfer."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"new_nn_arch: dict"}),": A new dictionary representing the transferred neural network architecture."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"def transfer_nn_arch(from_genie_model: GenieModel, transfer_data: TransferModel, from_nn_arch: dict) -> dict: pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"transfer_specifics",children:"transfer_specifics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Transfer model-specific configuration data from a source ",(0,i.jsx)(n.code,{children:"GenieModel"})," using the ",(0,i.jsx)(n.code,{children:"TransferModel"})," and an existing ",(0,i.jsx)(n.code,{children:"from_specifics"})," dictionary."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Takes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_genie_model: GenieModel"}),": The source model containing the specifics to transfer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer_data: TransferModel"}),": Metadata and rules guiding the transfer of specific attributes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_specifics: dict"}),": Dictionary containing specific configurations or parameters to be transferred."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"new_specifics: dict"}),": A dictionary containing the transferred and possibly modified specifics."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"def transfer_specifics(from_genie_model: GenieModel, transfer_data: TransferModel, from_specifics: dict) -> dict: pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.h3,{id:"transfer_models",children:"transfer_models"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description"}),": Transfer model files and associated resources from a source ",(0,i.jsx)(n.code,{children:"GenieModel"})," using ",(0,i.jsx)(n.code,{children:"TransferModel"})," metadata, updating paths accordingly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Takes"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_genie_model: GenieModel"}),": The source model containing the data and files to transfer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transfer_data: TransferModel"}),": Transfer metadata that governs how model components are migrated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"from_model_path: Path"}),": Filesystem path to the source model directory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"to_model_path: Path"}),": Filesystem path to the target model directory where the data will be copied."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Returns: Nothing"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"def transfer_models(from_genie_model: GenieModel, transfer_data: TransferModel, from_model_path: Path, to_model_path: Path): pass\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var r=s(6540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);