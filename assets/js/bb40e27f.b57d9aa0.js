"use strict";(self.webpackChunkuser_manual=self.webpackChunkuser_manual||[]).push([[6689],{8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>d});var r=s(6540);const i={},t=r.createContext(i);function c(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(t.Provider,{value:n},e.children)}},9685:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"simpackage/spice/spiceparser","title":"Spice Parser","description":"Parses SPICE netlists into structured AST representations.","source":"@site/connectors/simpackage/spice/spiceparser.md","sourceDirName":"simpackage/spice","slug":"/simpackage/spice/spiceparser","permalink":"/connectors/simpackage/spice/spiceparser","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"connectorsSidebar","previous":{"title":"Spice AST","permalink":"/connectors/simpackage/spice/spice_ast"},"next":{"title":"SPICEVariants","permalink":"/connectors/simpackage/spice/spicevariants"}}');var i=s(4848),t=s(8453);const c={},d="Spice Parser",o={},l=[{value:"Attributes",id:"attributes",level:2},{value:"<strong>Constructor</strong>",id:"constructor",level:3},{value:"<strong>Main Parsing Methods</strong>",id:"main-parsing-methods",level:3},{value:"<strong>Expression Parsing</strong>",id:"expression-parsing",level:3},{value:"<strong>Connection and Feature Parsing</strong>",id:"connection-and-feature-parsing",level:3},{value:"<strong>Source Text Utilities</strong>",id:"source-text-utilities",level:3},{value:"<strong>Token Matching and Validation</strong>",id:"token-matching-and-validation",level:3},{value:"<strong>Token Navigation</strong>",id:"token-navigation",level:3},{value:"<strong>Token Consumption</strong>",id:"token-consumption",level:3},{value:"<strong>Error Recovery</strong>",id:"error-recovery",level:3},{value:"<strong>Circuit Building</strong>",id:"circuit-building",level:3},{value:"<strong>Token Validation Utilities</strong>",id:"token-validation-utilities",level:3},{value:"<strong>Properties</strong>",id:"properties",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"spice-parser",children:"Spice Parser"})}),"\n",(0,i.jsx)(n.p,{children:"Parses SPICE netlists into structured AST representations."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"class SpiceParser:\r\n    delims: dict[SpiceTokenKind, SpiceTokenKind]\r\n    lexer: SpiceLexer\r\n    tokens: list[SpiceToken]\r\n    current: int\r\n    context: list[str]\r\n    circuits: dict[str, CircuitDef]\r\n    errors: list[str]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"attributes",children:"Attributes"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Name"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Type"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Description"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"delims"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"dict[SpiceTokenKind, SpiceTokenKind]"})}),(0,i.jsx)(n.td,{children:"Maps opening tokens (parentheses, braces, quotes, etc.) to their matching closing tokens"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"lexer"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"SpiceLexer"})}),(0,i.jsx)(n.td,{children:"Tokenizer for SPICE source code"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"tokens"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list[SpiceToken]"})}),(0,i.jsx)(n.td,{children:"List of tokens generated from the lexer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"current"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsx)(n.td,{children:"Current token index during parsing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"context"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list[str]"})}),(0,i.jsx)(n.td,{children:'Parsing context stack (e.g., current subcircuit, defaults to ["main"])'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"circuits"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"dict[str, CircuitDef]"})}),(0,i.jsx)(n.td,{children:'Parsed circuits by name, with "main" as the root circuit'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"errors"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list[str]"})}),(0,i.jsx)(n.td,{children:"Collected error messages during parsing"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"constructor",children:(0,i.jsx)(n.strong,{children:"Constructor"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def __init__(self, source: str) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"source"})," (str): The SPICE source text to parse"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Initializes the parser with SPICE source text and sets up the lexer and parsing state."]}),"\n",(0,i.jsx)(n.h3,{id:"main-parsing-methods",children:(0,i.jsx)(n.strong,{children:"Main Parsing Methods"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def parse(self) -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Main parse loop; processes components, dot-commands, and recovers from errors."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def dot_command(self) -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Handles SPICE dot-commands (.param, .subckt, .include, .lib, .ends)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def component(self) -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Parses a SPICE component line and adds it to the current circuit."]}),"\n",(0,i.jsx)(n.h3,{id:"expression-parsing",children:(0,i.jsx)(n.strong,{children:"Expression Parsing"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_expression(self) -> Expression\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Consumes an expression starting at the current token."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_delimited_expression(self, delimiter: SpiceTokenKind) -> Expression\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"delimiter"})," (SpiceTokenKind): The delimiter token kind that encloses the expression"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Reads expressions enclosed by delimiters (e.g., parentheses)."]}),"\n",(0,i.jsx)(n.h3,{id:"connection-and-feature-parsing",children:(0,i.jsx)(n.strong,{children:"Connection and Feature Parsing"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_connections(self, max_connections: int) -> list[str]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"max_connections"})," (int): Maximum number of connections to read"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Reads node connections for a component or subcircuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_features(self) -> tuple[list[Feature], list[str]]\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Extracts features (parameter assignments) and outliers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def find_first_feature_ident(self) -> int\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Detects the first feature identifier following a component."]}),"\n",(0,i.jsx)(n.h3,{id:"source-text-utilities",children:(0,i.jsx)(n.strong,{children:"Source Text Utilities"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_source_snippet(self, span: Span) -> str\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"span"})," (Span): The span to extract from the source"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Returns raw source code corresponding to a span."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_current_token_snippet(self) -> str\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Gets snippet text for the current token."]}),"\n",(0,i.jsx)(n.h3,{id:"token-matching-and-validation",children:(0,i.jsx)(n.strong,{children:"Token Matching and Validation"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_current_keyword_match(self, kw: str) -> bool\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kw"})," (str): The keyword to match against"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Checks if current token matches a keyword."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_keyword_match(self, token: SpiceToken | None, kw: str) -> bool\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"token"})," (SpiceToken | None): The token to check"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kw"})," (str): The keyword to match against"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Checks if a token matches a keyword."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def kind_matches(self, token: SpiceToken | None, kind: SpiceTokenKind) -> bool\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"token"})," (SpiceToken | None): The token to check"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kind"})," (SpiceTokenKind): The expected token kind"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Checks if token kind matches expected kind."]}),"\n",(0,i.jsx)(n.h3,{id:"token-navigation",children:(0,i.jsx)(n.strong,{children:"Token Navigation"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_at_end(self) -> bool\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Returns whether parsing has reached the end of tokens."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def bump(self) -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Advances the parser to the next token."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def peek(self, n: int = 1) -> SpiceToken | None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"n"})," (int): Number of tokens to look ahead (default: 1)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Looks ahead n tokens without consuming."]}),"\n",(0,i.jsx)(n.h3,{id:"token-consumption",children:(0,i.jsx)(n.strong,{children:"Token Consumption"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_until(self, kind: SpiceTokenKind) -> list[SpiceToken]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kind"})," (SpiceTokenKind): The token kind to consume until"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Consumes tokens until a specific kind is found."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_while(self, f: Callable[[SpiceToken], bool]) -> list[SpiceToken]\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"f"})," (Callable[[SpiceToken], bool]): Predicate function to test tokens"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Consumes tokens while predicate f is true."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_until_expression_token(self) -> list[SpiceToken]\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Consumes tokens until an expression token or new beginning is found."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eat_until_unescaped_whitespace(self) -> list[SpiceToken]\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Consumes until unescaped whitespace is found."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def skip_whitespaces(self) -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Skips whitespace tokens."]}),"\n",(0,i.jsx)(n.h3,{id:"error-recovery",children:(0,i.jsx)(n.strong,{children:"Error Recovery"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def recover(self) -> None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Error recovery; skips tokens until a valid start (Component or Dot)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_error(self, message: str) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"message"})," (str): Error message to record"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Records a parsing error."]}),"\n",(0,i.jsx)(n.h3,{id:"circuit-building",children:(0,i.jsx)(n.strong,{children:"Circuit Building"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_component(self, c: Component) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"c"})," (Component): The component to add"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Adds a component to the current circuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_parameter(self, p: Feature) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"p"})," (Feature): The parameter to add"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Adds a parameter to the current circuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_parameters(self, p: list[Feature]) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"p"})," (list[Feature]): The parameters to add"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Adds multiple parameters."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_subckt(self, name: str, connections: list[str], formal_parameters: list[Feature]) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"name"})," (str): Name of the subcircuit"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"connections"})," (list[str]): Node connections for the subcircuit"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"formal_parameters"})," (list[Feature]): Formal parameters of the subcircuit"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Defines a new subcircuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_include(self, path: Span) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"path"})," (Span): Path span for the include statement"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Adds an .include statement to the current circuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_lib(self, path: Span, argument: Optional[Span]) -> None\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"path"})," (Span): Path span for the library file"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"argument"})," (Optional[Span]): Optional argument for the library"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Adds a .lib statement with optional argument."]}),"\n",(0,i.jsx)(n.h3,{id:"token-validation-utilities",children:(0,i.jsx)(n.strong,{children:"Token Validation Utilities"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def maybe_expression_token(self, kind: SpiceTokenKind) -> bool\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kind"})," (SpiceTokenKind): The token kind to check"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Checks if a token kind can start an expression."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_closing_same(self, delimiter: SpiceTokenKind) -> bool\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"delimiter"})," (SpiceTokenKind): The delimiter to check"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Determines if a delimiter can close itself."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def is_new_beginning(self, token: SpiceToken | None) -> bool\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"token"})," (SpiceToken | None): The token to check"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Checks if token starts a new construct (component/dot)."]}),"\n",(0,i.jsx)(n.h3,{id:"properties",children:(0,i.jsx)(n.strong,{children:"Properties"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@property\r\ndef current_token(self) -> SpiceToken | None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Returns the current token."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@property\r\ndef prev_token(self) -> SpiceToken | None\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Returns the previous token."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@property\r\ndef circuit(self) -> CircuitDef\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Description:"}),' Returns the root "main" circuit definition.']})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);